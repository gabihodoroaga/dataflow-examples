package geolocation

import com.google.api.services.bigquery.model.TableRow
import com.google.gson.Gson
import com.google.gson.JsonElement
import com.google.gson.JsonObject
import org.apache.beam.sdk.Pipeline
import org.apache.beam.sdk.io.gcp.bigquery.BigQueryIO
import org.apache.beam.sdk.io.gcp.bigquery.BigQueryIO.Write.CreateDisposition
import org.apache.beam.sdk.io.gcp.bigquery.BigQueryIO.Write.WriteDisposition
import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO
import org.apache.beam.sdk.metrics.Metrics
import org.apache.beam.sdk.options.Description
import org.apache.beam.sdk.options.PipelineOptionsFactory
import org.apache.beam.sdk.options.StreamingOptions
import org.apache.beam.sdk.options.Validation
import org.apache.beam.sdk.transforms.DoFn
import org.apache.beam.sdk.transforms.ParDo
import org.slf4j.LoggerFactory

interface DemoPipelineOptions : StreamingOptions {
    @get:Description("Pub/Sub subscription to read from.")
    @get:Validation.Required
    var inputSubscription: String

    @get:Description(
            "BigQuery table to write to, in the form 'project:dataset.table' or 'dataset.table'."
    )
    @get:Validation.Required
    var outputTable: String

    @get:Description(
            "The build number generated by the deploy script to keep track of the version deployed in production"
    )
    var buildNumber: String
}

inline fun <reified T> JsonElement?.getValue(): T? {
    if (this == null || !this.isJsonPrimitive()) {
        return null
    }

    when (T::class) {
        String::class ->
                return try {
                    this.getAsString() as T?
                } catch (e: Exception) {
                    null
                }
        Float::class ->
                return try {
                    this.getAsFloat() as T?
                } catch (e: Exception) {
                    null
                }
        Double::class ->
                return try {
                    this.getAsDouble() as T?
                } catch (e: Exception) {
                    null
                }
        Long::class ->
                return try {
                    this.getAsLong() as T?
                } catch (e: Exception) {
                    null
                }
    }
    return null
}

class ParseJsonWithLocation() : DoFn<String, TableRow>() {

    companion object {
        val GSON = Gson()
        val LOGGER = LoggerFactory.getLogger("dataflow.e2e.demo.ParseJsonWithLocation")
    }

    val totalMessages = Metrics.counter(ParseJsonWithLocation::class.java, "totalMessages")
    val invalidMessages = Metrics.counter(ParseJsonWithLocation::class.java, "invalidMessages")
    val invalidLocation = Metrics.counter(ParseJsonWithLocation::class.java, "invalidLocation")

    @ProcessElement
    fun processElement(context: ProcessContext) {
        totalMessages.inc()
        val element = context.element()
        val msg: JsonObject
        val tableRow = TableRow()

        try {
            msg = GSON.fromJson(element, JsonObject::class.java)
        } catch (e: Exception) {
            LOGGER.error("error pasing message: ${element}, error: ${e}")
            invalidMessages.inc()
            return
        }

        tableRow.set("type", msg.get("type").getValue<String>())
        tableRow.set("data", msg.get("data").getValue<String>())
        val lat = msg.get("lat").getValue<Double>()
        val lon = msg.get("log").getValue<Double>()
        if (lat != null && lon != null) {
            tableRow.set("lat", lat)
            tableRow.set("log", lon)
            if (!CityLocator.findCity(
                            tableRow,
                            msg.get("lat").getAsDouble(),
                            msg.get("lon").getAsDouble()
                    )
            ) {
                invalidLocation.inc()
            }
        }
        context.output(tableRow)
    }
}

fun main(args: Array<String>) {

    val options =
            PipelineOptionsFactory.fromArgs(*args)
                    .withValidation()
                    .`as`(DemoPipelineOptions::class.java)

    val tableSchemaJson = {}.javaClass.getResource("/schema.json").readText()

    val p = Pipeline.create(options)

    p.apply("ReadFromPubsub", PubsubIO.readStrings().fromSubscription(options.inputSubscription))
            .apply("ParseJsonMessage", ParDo.of(ParseJsonWithLocation()))
            .apply(
                    "WriteToBigQuery",
                    BigQueryIO.writeTableRows()
                            .to(options.outputTable)
                            .withJsonSchema(tableSchemaJson)
                            .withCreateDisposition(CreateDisposition.CREATE_IF_NEEDED)
                            .withWriteDisposition(WriteDisposition.WRITE_APPEND)
            )

    p.run()
}
